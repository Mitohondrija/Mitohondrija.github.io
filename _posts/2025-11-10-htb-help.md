---
layout: post
title: "HTB: Help"
date: 2025-11-10 20:00:00 +0100
categories: [HackTheBox, Writeups]
tags: [HTB, GraphQL, SQLi, Exploitation]
description: "HackTheBox 'Help' — GraphQL enumeration, SQLi, RCE and privilege escalation walkthrough."
permalink: /writeups/htb-help/
---
# Overview

**Machine Name: Help**

**Difficulty:** Easy

**Date:** November 2025

**Skills Demonstrated:**

- GraphQL enumeration and exploitation
- Blind SQL Injection with `sqlmap`
- File upload to Remote Code Execution (RCE)
- Exploit customization and debugging
- Privilege escalation via local kernel vulnerability

**Tools Used:**

- `nmap`, `gobuster`, `sqlmap`, `jq`, `Burp Suite`
- `python`, `gcc`, `crackstation.net`
- `netcat`, `reverse shell`, `curl`, `whoami`, `uname`

# Enumeration

## Network Enumeration

```jsx
nmap -sC -sV -oA nmap <target ip address>
```

**Result:** 

![image.png](/assets/img/htb-help/image.png)

Results are three open ports: 

- **Port 80 (HTTP):** Standard Apache web server
- **Port 3000:** Here it serves a Node.js Express app, later discovered to expose a GraphQL API.
- **Port 22 (SSH):** Might allow direct shell access if valid credentials are found later.

## Web Enumeration - Port 80 (Apache)

![image.png](/assets/img/htb-help/image%201.png)

Navigating to target ip displays the default Apache2 Debian page.

This suggests either:

- The real web application is hidden under a different path, or
- Misconfigured virtual hosts

I will run gobuster to see if it can find anything interesting.

```jsx
gobuster dir -u http://help.htb/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-small.txt -t 50 -o gobuster.txt

```

![image.png](/assets/img/htb-help/image%202.png)

**Discovered Directories:**

- `/javascript/`
    
    ![image.png](/assets/img/htb-help/image%203.png)
    
- `/support/` → Exposes a full web application for submitting tickets to the customer support: **HelpDeskZ**

![image.png](/assets/img/htb-help/image%204.png)

This HelpDeskZ is a PHP-based ticket system. It’s open-source, and it has known vulnerabilities for some of the older versions. The only problem is that it’s not really known which version of this software are we working with here, and current up-to-date version is 2.0.2.

![image.png](/assets/img/htb-help/image%205.png)

![image.png](/assets/img/htb-help/image%206.png)

After some meddling with the version 2.0.2 I found out that it contains the README.md file that mentions a version of the software. I will try to search for this file on the target machine, and try to find out which version is on it. I found out that it’s a 1.0.2, the older version that we have two exploits for.

![image.png](/assets/img/htb-help/image%207.png)

## Web Enumeration - Port 3000 (GraphQL)

Visiting port **3000** revealed a custom web interface served by an Express.js application. Port 3000 is a common default for web apps during development and testing, so seeing a developer-facing UI here is expected. Many projects also host their API endpoints on the same port.

![image.png](/assets/img/htb-help/image%208.png)

![image.png](/assets/img/htb-help/image%209.png)

Looking for common API routes, `/graphql` is frequently used as the GraphQL entrypoint in tutorials and dev setups. Requesting `/graphql` confirmed that the application exposes a GraphQL API — an attractive target for further testing because a misconfigured GraphQL endpoint can expose a lot of data. The port’s default page also mentioned credentials, which increased the likelihood of finding user-related types and fields.

![image.png](/assets/img/htb-help/image%2010.png)

In GraphQL everything has a **type**; types define the shape of data and enforce type safety. The UI suggested a `User` type, so I crafted a query that requested a `User` object. I formatted responses with `jq` to improve readability.

![image.png](/assets/img/htb-help/image%2011.png)

![image.png](/assets/img/htb-help/image%2012.png)

The first request returned an error complaining about missing subfields, which is expected for GraphQL — you must request specific fields. After adding obvious `User` fields, the query succeeded and returned information for a user.

![image.png](/assets/img/htb-help/image%2013.png)

I then attempted to retrieve the password-related field and received a password hash.

![image.png](/assets/img/htb-help/image%2014.png)

A quick lookup of the hash on CrackStation identified it as an **MD5** hash; the recovered plaintext password was `godhelpmeplz`.

![image.png](/assets/img/htb-help/image%2015.png)

Armed with those credentials, I tried logging into the HelpDesk login form found earlier — the credentials worked and the login was successful.

![image.png](/assets/img/htb-help/image%2016.png)

# HelpDeskZ Web App Exploitation (Auth + SQL Injection)

Exploring around the page we can see a dashboard with submitted tickets, option to submit new tickets, ability to attach files on the ticket submission.

While exploring the HelpDeskZ application, we observed a dashboard that allows:

- Viewing submitted tickets
- Submitting new tickets
- Uploading attachments during ticket submission

There are several ways this app could be exploited.

## SQL Injection - Exploiting the msg_id parameter

In this vulnerability, the attacker targets the `msg_id` parameter, which is **not properly sanitized** and accepts **raw string input**. Because the application doesn't enforce strict typing, a malicious user can inject custom SQL logic into the query.

![image.png](/assets/img/htb-help/image%2017.png)

This means that even if all of the original three-part checks are false, the `OR` expression alone can make the `WHERE` clause true — if the condition the attacker specified is valid.

Now, let’s say that the third parameter was not sanitized properly and we want to target it, but there is a 4th parameter that we cannot control. That could cause our `OR` condition to be ineffective, since it's no longer in our control. In that case, the attacker adds `-- -`, which **comments out** the rest of the query.

Everything after that is treated like a comment and is ignored by the SQL engine.

![image.png](/assets/img/htb-help/image%2018.png)

The web app builds the SQL `WHERE` clause using the `param[]` values without sanitizing one of them (in this case it's `msg_id`), so an authenticated user can inject boolean SQL conditions into the **attachment download** request.

The script abuses that to perform **boolean-based blind extraction** (character-by-character) from the `information_schema` and the `staff` table, recover the **admin username and password hash**, and then download attachments or files.

Exploit begins with this piece of code, found in the HelpDesk (`view_tickets_controller.php`):

```php
$file = $db->fetchRow("SELECT a.*, COUNT(id) as total FROM ".TABLE_PREFIX."attachments WHERE id='".$db->real_escape_string($params[2])."' AND ticket_id=".$params[3]." AND msg_id=".$params[4]);

```

The **third parameter** (`$params[3]`, `msg_id`) is concatenated raw into SQL, with no escaping or type checking.

- `SUBSTR()` – used to extract one character from a string at a specific position
- `ASCII()` – converts that character into its numeric code (e.g., 97 is `'a'`, 48 is `'0'`)

This value is then compared to a guessed value, producing a **TRUE/FALSE** result — which enables **blind SQL injection**.

**SUBMITTING A TICKET**

Once logged in, the HelpDeskZ interface provides an option to submit a new ticket via the **"Submit a Ticket"** tab. Notably, the ticket submission form allows users to **attach files**. Any functionality involving file uploads is worth examining for potential vulnerabilities (e.g., file upload bypass, LFI, or RCE). Always test file upload features when available.

![image.png](/assets/img/htb-help/image%2019.png)

![image.png](/assets/img/htb-help/image%2020.png)

After submitting a ticket, we can navigate to the **"My Tickets"** section to view all previously submitted entries.

In this example, we see our test ticket titled `testingsqli` listed.

![image.png](/assets/img/htb-help/image%2021.png)

![image.png](/assets/img/htb-help/image%2022.png)

Clicking the ticket subject opens the full ticket view. The URL to download our uploaded attachment is:

![image.png](/assets/img/htb-help/image%2023.png)

To confirm the presence of **boolean-based blind SQL injection**, we modify the attachment download request by appending conditions to the vulnerable `msg_id` parameter (which corresponds to `param[]=6` in the request).

![image.png](/assets/img/htb-help/image%2024.png)

When appending the following to the URL:

![image.png](/assets/img/htb-help/image%2025.png)

The server responds as expected — the file downloads successfully. This indicates that the injected condition (`1=1`) evaluates as **true**, and the application proceeds with the query.

This confirms that this is indeed a blind injection.

Once we've confirmed the injection point via browser testing, the next step is to **intercept and test it with Burp Suite**.

The request to download the file (via the vulnerable `msg_id` parameter) looks like this:

![image.png](/assets/img/htb-help/image%2026.png)

We capture this request in **Burp Repeater** and save it locally as a `.txt` file. Next, we feed it into `sqlmap` to automate the injection testing.

![image.png](/assets/img/htb-help/image%2027.png)

Running `sqlmap` against the saved request revealed that the application is vulnerable to:

- **Boolean-based blind SQL injection**
- **Time-based blind SQL injection**

This confirms that we have a blind injection point we can exploit further.

After verifying the vulnerability, I used `sqlmap` to **enumerate** the available databases, and found some that looked interesting.

From there, I dumped the contents of the `staff` table, which included:

- Admin usernames
- Password hashes

SQLMap was also able to **crack one of the hashes automatically**, revealing admin credentials.

![image.png](/assets/img/htb-help/image%2028.png)

![image.png](/assets/img/htb-help/image%2029.png)

![image.png](/assets/img/htb-help/image%2030.png)

From the previous SQL injection, we successfully extracted admin credentials:

Email: [support@mysite.com](mailto:support@mysite.com)

Password: Welcome1

According to our earlier nmap scan, the server is running an open SSH service, so we can attempt to authenticate using the recovered credentials.

The only challenging part of establishing the SSH connection was identifying the correct **username**, as only the email (`support@mysite.com`) and password (`Welcome1`) were known. Several common usernames were tested — including `admin`, `root`, and `helpme`. Eventually, the correct username was found to be `help`.

Using the credentials `help:Welcome1`, we successfully logged in via SSH and retrieved the `user.txt` flag.

![image.png](/assets/img/htb-help/image%2031.png)

![image.png](/assets/img/htb-help/image%2032.png)

After gaining a foothold as the `help` user, the next objective was to **escalate privileges** to root. Running `uname -a` revealed the following:

![image.png](/assets/img/htb-help/image%2033.png)

This shows the system is running a **relatively old kernel version (from 2018)**, which is often vulnerable to known local privilege escalation (LPE) exploits.

To identify a suitable exploit, I searched for known vulnerabilities affecting Ubuntu 16.04, and I managed to find few that might work:

![image.png](/assets/img/htb-help/image%2034.png)

![image.png](/assets/img/htb-help/image%2035.png)

![image.png](/assets/img/htb-help/image%2036.png)

I downloaded the second exploit and proceeded to compile it locally, before sending it to the target via python server.

![image.png](/assets/img/htb-help/image%2037.png)

![image.png](/assets/img/htb-help/image%2038.png)

![image.png](/assets/img/htb-help/image%2039.png)

I managed to download it and add execute permission via chmod. Attempting to run the compiled binary on the target machine resulted in the following error:

![image.png](/assets/img/htb-help/image%2040.png)

This indicates that the binary was linked against **GLIBC 2.34**, which does **not exist** on the target.

![image.png](/assets/img/htb-help/image%2041.png)

![image.png](/assets/img/htb-help/image%2042.png)

This confirms a **GLIBC version mismatch** — the binary compiled on my machine is not compatible with the older libc version present on the target system.

After encountering a **GLIBC version mismatch** while compiling the exploit on my local machine, I decided to take a more direct approach:

I downloaded and compiled the exploit directly on the target machine — using its native toolchain.

![image.png](/assets/img/htb-help/image%2043.png)

![image.png](/assets/img/htb-help/image%2044.png)

2ND WAY TO EXPLOIT THIS MACHINE

Another way to exploit this machine is by leveraging a known vulnerability in HelpDeskZ v1.0.2 — an **arbitrary file upload** flaw that leads directly to **remote code execution (RCE)**, and does **not require authentication**.

![image.png](/assets/img/htb-help/image%2045.png)

As we know the application let’s the user upload files to the app via submit a ticket form. It was probably intended for users to upload the screenshots of the problem or maybe logs, or something. However it does not properly sanitize the input, and let’s us upload a .php files, which could lead to the execution on the server.

Now, it seems that the developer was aware of these threats, so they created the system that renames every uploaded file using a random name, so attacker would not be able to activate it’s code as he does not know the name. The problem was in this part of the code.

The HelpDeskZ application allows users to upload files when submitting a support ticket — typically for logs or screenshots.

However:

- It **does not validate file extensions or MIME types properly**
- It **allows `.php` files** to be uploaded
- It **renames files using a predictable algorithm** — making it possible to guess the final name

The developer tried to mitigate arbitrary execution by renaming uploaded files to an MD5 hash based on:

- The original filename
- The current server-side **timestamp**
- The file extension

Here’s the vulnerable logic (from `submit_ticket_controller.php`):

![image.png](/assets/img/htb-help/image%2046.png)

This renaming mechanism **does not prevent exploitation** because:

- The MD5 hash is generated using **known inputs**
- We can estimate the server time (especially if we submit the upload and immediately brute-force the hash)
- The web root still serves these uploaded files — they’re accessible from the frontend

So I tried uploading the reverse shell to the form, and got an error.

![image.png](/assets/img/htb-help/image%2047.png)

If you take a look at the source code of the **HelpDeskZ** you will see that the application does implement a check to **validate uploaded files**, particularly to block certain extensions such as `.php`.

Here’s the relevant code snippet from `submit_ticket_controller.php`:

![image.png](/assets/img/htb-help/image%2048.png)

This logic correctly **detects and blocks disallowed file types** like `.php`, but here’s the catch:

The application warns the user but doesn’t actually delete or prevent the file from being stored on the server.

If you upload a `.php` file:

- The UI shows an error (e.g., `File is not allowed`)
- But the file may still be written to disk

This opens up the possibility of **triggering the uploaded file directly**, despite the error shown to the user — making it a viable RCE vector.

At this point, the challenge became identifying **where uploaded files are stored** and **how to access them** — since browsing the ticket system requires an **authenticated session**.

We previously located the source code for **HelpDeskZ** on GitHub. Looking into the directory structure, we discovered:

![image.png](/assets/img/htb-help/image%2049.png)

![image.png](/assets/img/htb-help/image%2050.png)

Based on this, it’s reasonable to assume that **uploaded attachments** are stored in this path.

To verify the existence of the `tickets/` directory, I ran `gobuster` against the `/uploads/` path using a common wordlist:

![image.png](/assets/img/htb-help/image%2051.png)

With the upload path confirmed, I attempted to execute the previously uploaded **PHP reverse shell** directly. However, running the exploit script (likely written in Python 2) produced this error:

![image.png](/assets/img/htb-help/image%2052.png)

This error occurs because the exploit was written for **Python 2**, but it was run in a **Python 3 environment** — where `print` is a function and must use parentheses. After fixing it and running, I got another error.

![image.png](/assets/img/htb-help/image%2053.png)

After debugging the exploit script, it became clear that the issue was with the **constructed URL** used to check for the uploaded shell.

In the exploit script, the URL is assembled like this:

![image.png](/assets/img/htb-help/image%2054.png)

However, the `helpdeskzBaseUrl` was defined without a trailing slash. As a result, the final URL became malformed (e.g., `.../ticketsphp-reverse-shell.php` instead of `.../tickets/php-reverse-shell.php`).

![image.png](/assets/img/htb-help/image%2055.png)

We now have a shell on the target — unauthenticated, remote code execution confirmed.

![image.png](/assets/img/htb-help/image%2056.png)